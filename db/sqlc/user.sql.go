// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.19.1
// source: user.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createUser = `-- name: CreateUser :one
INSERT INTO
  users (username, email, hashed_password, full_name)
VALUES
  ($1, $2, $3, $4) RETURNING username, full_name, email, hashed_password, password_changed_at, created_at, is_email_activated
`

type CreateUserParams struct {
	Username       string `db:"username"`
	Email          string `db:"email"`
	HashedPassword string `db:"hashed_password"`
	FullName       string `db:"full_name"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Username,
		arg.Email,
		arg.HashedPassword,
		arg.FullName,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.CreatedAt,
		&i.IsEmailActivated,
	)
	return i, err
}

const getUser = `-- name: GetUser :one
SELECT
  username, full_name, email, hashed_password, password_changed_at, created_at, is_email_activated
FROM
  users
WHERE
  username = $1
LIMIT 1
`

func (q *Queries) GetUser(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUser, username)
	var i User
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.CreatedAt,
		&i.IsEmailActivated,
	)
	return i, err
}

const updateUserUsingCaseFirst = `-- name: UpdateUserUsingCaseFirst :one
UPDATE users 
SET 
  hashed_password = CASE WHEN $1::bool THEN $2 ELSE hashed_password END,
  email = CASE WHEN $3::bool THEN $4 ELSE email END,
  full_name = CASE WHEN $5::bool THEN $6 ELSE full_name END
WHERE 
  username = $7
RETURNING username, full_name, email, hashed_password, password_changed_at, created_at, is_email_activated
`

type UpdateUserUsingCaseFirstParams struct {
	SetHashedPassword bool   `db:"set_hashed_password"`
	HashedPassword    string `db:"hashed_password"`
	SetEmail          bool   `db:"set_email"`
	Email             string `db:"email"`
	SetFullName       bool   `db:"set_full_name"`
	FullName          string `db:"full_name"`
	Username          string `db:"username"`
}

func (q *Queries) UpdateUserUsingCaseFirst(ctx context.Context, arg UpdateUserUsingCaseFirstParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserUsingCaseFirst,
		arg.SetHashedPassword,
		arg.HashedPassword,
		arg.SetEmail,
		arg.Email,
		arg.SetFullName,
		arg.FullName,
		arg.Username,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.CreatedAt,
		&i.IsEmailActivated,
	)
	return i, err
}

const updateUserUsingCaseSecond = `-- name: UpdateUserUsingCaseSecond :one
UPDATE users 
SET 
  hashed_password = coalesce($1, hashed_password),
  password_changed_at = coalesce($2, password_changed_at),
  email = coalesce($3, email),
  full_name = coalesce($4, full_name),
  is_email_activated = coalesce($5, is_email_activated)
WHERE 
  username = $6
RETURNING username, full_name, email, hashed_password, password_changed_at, created_at, is_email_activated
`

type UpdateUserUsingCaseSecondParams struct {
	HashedPassword    pgtype.Text        `db:"hashed_password"`
	PasswordChangedAt pgtype.Timestamptz `db:"password_changed_at"`
	Email             pgtype.Text        `db:"email"`
	FullName          pgtype.Text        `db:"full_name"`
	IsEmailActivated  pgtype.Bool        `db:"is_email_activated"`
	Username          string             `db:"username"`
}

func (q *Queries) UpdateUserUsingCaseSecond(ctx context.Context, arg UpdateUserUsingCaseSecondParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUserUsingCaseSecond,
		arg.HashedPassword,
		arg.PasswordChangedAt,
		arg.Email,
		arg.FullName,
		arg.IsEmailActivated,
		arg.Username,
	)
	var i User
	err := row.Scan(
		&i.Username,
		&i.FullName,
		&i.Email,
		&i.HashedPassword,
		&i.PasswordChangedAt,
		&i.CreatedAt,
		&i.IsEmailActivated,
	)
	return i, err
}
